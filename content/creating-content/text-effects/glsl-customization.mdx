# GLSL Customization

import { Callout, Tabs } from 'nextra/components'

One of the most powerful features of Oraxen's text effects system is the ability to customize or create new effects using GLSL (OpenGL Shading Language). The `text_effects.yml` file contains the GLSL snippets that define how each effect works.

## GLSL Snippet Structure

Each effect can define snippets for vertex and/or fragment shaders:

```yaml filename="text_effects.yml"
effects:
  my_effect:
    id: 0              # Effect ID (0-7)
    enabled: true      # Enable/disable this effect
    description: My custom effect
    snippets:
      - targets:                     # Optional: version constraints
          min_pack_format: 34
          max_pack_format: 46
          min_version: "1.21"
          max_version: "1.21.5"
        vertex: |
          // Vertex shader code (position effects)
          pos.y += sin(timeSeconds) * 0.5;
        fragment: |
          // Fragment shader code (color effects)
          texColor.rgb = vec3(1.0, 0.0, 0.0);
```

## Available Variables

These variables are available in your GLSL snippets:

| Variable | Type | Description |
|----------|------|-------------|
| `timeSeconds` | `float` | Game time in seconds (for animation) |
| `speed` | `float` | Speed parameter (1-7) decoded from color |
| `param` | `float` | Extra parameter (0-7) decoded from color |
| `charIndex` | `float` | Character index in the string |
| `effectType` | `int` | The effect type ID |
| `pos` | `vec3` | Vertex position (vertex shader only) |
| `texColor` | `vec4` | Texture color RGBA (fragment shader only) |

## Shared Code

The `shared` section defines reusable GLSL functions that are available to all effects:

```yaml filename="text_effects.yml"
shared:
  fragment_prelude: |
    // HSV to RGB conversion - useful for color effects
    vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

  vertex_prelude: |
    // Add any vertex shader helper functions here
```

## Built-in Effect Examples

<Tabs items={['Rainbow', 'Wave', 'Shake', 'Pulse', 'Gradient', 'Typewriter']}>
<Tabs.Tab>
**Rainbow Effect** - Cycles through hue colors over time

```glsl
// Fragment shader
float hue = fract(charIndex * 0.03 + timeSeconds * speed * 0.03);
vec3 rgb = hsv2rgb(vec3(hue, 0.9, 1.0));
texColor.rgb = rgb;
```

**How it works:**
- Uses `charIndex` to offset each character's hue for a gradient effect
- Multiplies by `timeSeconds * speed` to animate the color cycling
- `hsv2rgb()` converts the hue value to RGB colors
- Saturation is fixed at 0.9, brightness at 1.0

</Tabs.Tab>
<Tabs.Tab>
**Wave Effect** - Vertical sine wave motion

```glsl
// Vertex shader
float phase = charIndex * 0.6 + timeSeconds * speed * 2.0;
float amplitude = max(1.0, param) * 0.15;
pos.y += sin(phase) * amplitude;
```

**How it works:**
- Each character has a phase offset based on its index
- `sin(phase)` creates the wave motion
- `param` controls the wave amplitude (height)
- `speed` controls how fast the wave moves

</Tabs.Tab>
<Tabs.Tab>
**Shake Effect** - Random jitter

```glsl
// Vertex shader
float seed = charIndex + floor(timeSeconds * speed * 8.0);
float amplitude = max(1.0, param) * 0.15;
pos.x += (fract(sin(seed * 12.9898) * 43758.5453) - 0.5) * amplitude;
pos.y += (fract(sin(seed * 78.233) * 43758.5453) - 0.5) * amplitude;
```

**How it works:**
- Uses a pseudo-random number generator based on `sin()`
- `floor(timeSeconds * speed * 8.0)` creates discrete shake "frames"
- Random offset is applied to both X and Y positions
- `param` controls shake intensity

</Tabs.Tab>
<Tabs.Tab>
**Pulse Effect** - Opacity fades in/out

```glsl
// Fragment shader
float pulse = (sin(timeSeconds * speed * 0.5 + charIndex * 0.3) + 1.0) * 0.5;
texColor.a *= 0.3 + pulse * 0.7;
```

**How it works:**
- Uses `sin()` to oscillate between 0 and 1
- Adds `charIndex * 0.3` to offset each character's phase
- Multiplies the alpha channel to fade opacity
- Minimum opacity is 0.3 (30%)

</Tabs.Tab>
<Tabs.Tab>
**Gradient Effect** - Static color gradient

```glsl
// Fragment shader
float t = charIndex / 15.0;
vec3 startColor = vec3(1.0, 0.3, 0.3);  // Red
vec3 endColor = vec3(0.3, 0.3, 1.0);    // Blue
texColor.rgb = mix(startColor, endColor, t);
```

**How it works:**
- `charIndex / 15.0` normalizes character position to 0-1 range
- `mix()` interpolates between start and end colors
- This is a static effect (not animated)

**Customization tip:** Change `startColor` and `endColor` to create different gradients!

</Tabs.Tab>
<Tabs.Tab>
**Typewriter Effect** - Characters appear sequentially

```glsl
// Fragment shader
float reveal = floor(timeSeconds * speed * 4.0);
float alpha = step(charIndex, reveal);
texColor.a *= alpha;
```

**How it works:**
- `reveal` counts up in discrete steps as time progresses
- `step(charIndex, reveal)` returns 1.0 when `reveal >= charIndex`, 0.0 otherwise
- Characters appear one-by-one from left to right
- This is a one-way reveal (doesn't loop)

</Tabs.Tab>
</Tabs>

## Creating Custom Effects

To create your own effect:

1. Choose an effect ID (0-7) - you can replace an existing effect or use an unused ID
2. Add your effect to `text_effects.yml`:

```yaml filename="text_effects.yml"
effects:
  # Custom: Glowing text that pulses brighter and darker
  glow:
    id: 3  # Replaces pulse
    enabled: true
    description: Glowing brightness pulse
    snippets:
      - fragment: |
          float glow = (sin(timeSeconds * speed) + 1.0) * 0.5;
          float brightness = 0.7 + glow * 0.6;  // 0.7 to 1.3
          texColor.rgb *= brightness;
```

3. Reload Oraxen with `/oraxen reload all`
4. Test with `/oraxen texteffect basic glow Your glowing text!`

## GLSL Reference

### Common Functions

```glsl
sin(x), cos(x)       // Smooth oscillation (-1 to 1)
fract(x)             // Fractional part (0 to 1)
floor(x)             // Round down (for discrete steps)
step(edge, x)        // 0.0 if x < edge, else 1.0 (binary threshold)
clamp(x, min, max)   // Constrain value to range
mix(a, b, t)         // Linear interpolation
mod(x, y)            // Remainder (for looping)
abs(x)               // Absolute value
max(a, b), min(a, b) // Maximum/minimum of two values
pow(x, y)            // Power function
sqrt(x)              // Square root
length(vec)          // Vector length
normalize(vec)       // Unit vector
dot(a, b)            // Dot product
```

### Useful Patterns

```glsl
// Smooth oscillation between 0 and 1
float wave = (sin(timeSeconds) + 1.0) * 0.5;

// Discrete steps (for frame-like animation)
float frame = floor(timeSeconds * 10.0);  // 10 FPS

// Per-character phase offset
float phase = charIndex * 0.5 + timeSeconds;

// Pseudo-random based on seed
float rand = fract(sin(seed * 12.9898) * 43758.5453);

// Smooth step (ease in/out)
float t = smoothstep(0.0, 1.0, x);

// Ping-pong (oscillate 0 to 1 to 0)
float pingpong = abs(mod(timeSeconds, 2.0) - 1.0);

// Color from grayscale
vec3 color = vec3(grayscale);

// Darken color
texColor.rgb *= 0.5;

// Brighten color (may exceed 1.0)
texColor.rgb *= 1.5;

// Invert color
texColor.rgb = 1.0 - texColor.rgb;

// Desaturate (convert to grayscale)
float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
texColor.rgb = vec3(gray);
```

### Custom Effect Ideas

Here are some ideas for custom effects you can create:

**Breathing Effect** - Slow scale pulse
```glsl
// Vertex shader
float breath = (sin(timeSeconds * speed * 0.3) + 1.0) * 0.1 + 0.9;
pos *= breath;
```

**Color Shift** - Cycle through colors
```glsl
// Fragment shader
float shift = timeSeconds * speed * 0.1;
texColor.rgb = vec3(
    sin(shift) * 0.5 + 0.5,
    sin(shift + 2.094) * 0.5 + 0.5,
    sin(shift + 4.188) * 0.5 + 0.5
);
```

**Glitch Effect** - Random color/position jumps
```glsl
// Fragment shader
float glitch = step(0.95, fract(sin(floor(timeSeconds * 20.0) * charIndex) * 43758.5453));
texColor.rgb = mix(texColor.rgb, 1.0 - texColor.rgb, glitch);
```

**Fade In** - Characters fade in from transparent
```glsl
// Fragment shader
float fadeTime = 2.0;  // seconds to fully appear
float progress = clamp(timeSeconds / fadeTime, 0.0, 1.0);
float alpha = smoothstep(charIndex / 20.0, charIndex / 20.0 + 0.1, progress);
texColor.a *= alpha;
```

## Version-Specific Snippets

You can define different GLSL code for different Minecraft versions:

```yaml filename="text_effects.yml"
effects:
  custom:
    id: 0
    enabled: true
    snippets:
      # Snippet for 1.21.6+
      - targets:
          min_version: "1.21.6"
        fragment: |
          // Modern shader code
          texColor.rgb = modernEffect();

      # Fallback for older versions
      - targets:
          max_version: "1.21.5"
        fragment: |
          // Legacy shader code
          texColor.rgb = legacyEffect();
```

The first matching snippet (based on `targets`) is used. Snippets without targets always match.

### Target Options

| Option | Description |
|--------|-------------|
| `min_pack_format` | Minimum resource pack format |
| `max_pack_format` | Maximum resource pack format |
| `min_version` | Minimum Minecraft version (e.g., "1.21") |
| `max_version` | Maximum Minecraft version (e.g., "1.21.5") |

## Debugging Tips

<Callout type="info">
When developing custom effects, you can quickly test changes by using `/oraxen reload all` after editing `text_effects.yml`.
</Callout>

**Common issues:**

1. **Effect not showing**: Check that the effect ID matches what you're using in the command
2. **Syntax errors**: GLSL is strict - ensure semicolons and proper types
3. **Nothing visible**: Check if `texColor.a` is being set to 0
4. **Flickering**: Use `floor()` for discrete animations, not continuous values
5. **Wrong timing**: Remember `speed` is 1-7, multiply appropriately

**Test your GLSL locally:**
You can use online GLSL editors like [Shadertoy](https://www.shadertoy.com/) to prototype effects before adding them to Oraxen.
